---
layout: post
title: ruby元编程第一章读书笔记
category: 技术
tags: 
keywords: 元编程
description: 
---

ruby的类:
在ruby中定义类的语句和其他语句没有什么本质区别,如：

```
3.times do
  class C
  puts "hello"
  end
end

=> Hello
   Hello
   Hello
```

打开类：
但是这并不意味定义了三个同名的类，从某种意义上说，ruby的class关键字更像是一个作用于操作符而不是类型声明语句，它的确可以创建一个还不存在的类，不过可以把这个看成一种特殊情况，对于class关键字，其核心任务是把你带到类的上下文中。

你总是可以重新打开已经存在的类并对它进行动态修改，即使像String或Array这样标准库中的类也不例外。这种技术，可以简单成为*打开类（open class）*技术。

打开类带来的风险：
当对类添加方法时，可能会覆盖到该类原本就有的此方法,这就是打开类技术的隐患：如果你粗心地为某个类添加了某些功能，就可能遇到一些难以追踪的bug。


类的真相：
 
实例变量：
  对象中包含了实例变量：
```
  class MyClass
    def me
      @m = 1
    end
    
    def he
      @h = 1
    end
  end
 
 obj1 = MyClass.new
 obj1.instance_variables  # => []
 

 obj2 = MyClass.new
 obj2.me
 obj2.instance_variables  # => [:@m]
 obj2.he
 obj2.instance_variables  # => [:@m,:@h]

```

Ruby中对象的类和它的实例变量没有关系，当给实例变量赋值时，它们就生成了。因此，对同一个类，你可以创建具有不同实例变量的对象，例如：如果不曾调用obj1.me 或者he方法，那么obj1对象根本不会有任何实例变量。
你可以把Ruby中实力变量的名字和值理解为哈希表中的键值对，每一个对象的键值对都可能不同。


方法：
除了实例变量，对象还有方法。在对象内部，其仅仅包含它的实力变量以及一个对自身类的引用。
也就是说：一个对象的实例变量存在于对象本身，而一个对象的方法存在于对象自身的类。这就是为什么同一个类的对象共享同样的方法，但不共享实例变量的原因。

