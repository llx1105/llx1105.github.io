---
layout: post
title: ruby元编程第二章读书笔记
category: 技术
tags:
keywords: 元编程
description:
---

ruby是动态语言，不会像静态语言一样有静态类型检查。
书中通过一个重复代码重构的例子讲了两种通过动态的调用以及定义方法来消除重复代码。分别是动态派发技术以及method_missing方法。
## 动态方法：
### send 方法
正常情况下我们通过(.)来调用一个方法。


```
class MyClass
  def my_method(my_arg)
    my_arg * 3
  end
end

obj = myclass.new
obj.my_method(3) # => 6
```

还可以通过send方法来调用一个方法。如：

```
obj.send(:my_method, 3) # => 6
```
这是ruby一个很酷的特性，可以通过send()方法，把想调用的方法本身当做一个参数，这样就可以在代码运行期间，根据情况才决定调用哪一个方法，这种技术被
称作:* 动态派发(Dynamic Dispatch)*

###动态定义
除了动态调用方法外，还可以动态定义方法：

例子：

```
class MyClass
  define_method :my_method do |my_arg|
    my_arg * 3
  end
end

obj = myclass.new
obj.my_method(2) # => 6
```
其中define_method()方法在MyClass内部执行。因此my_method()定义为MyClass的实例方法。

### 幽灵方法 method_missing
在ruby中，你可以调用一个并不存在的方法。当一个方法被调用时，会沿着它的祖先链向上搜寻进入object类，并且最终来到kernel模块。由于没有找到这个方法，Kernel#method_missing()方法会抛出一个NoMethodError进行响应。
当然，一般情况下我们不会亲自调用method_missing()方法，我们通过覆写此方法使得可以调用实际上并不存在的方法。






